// --------------------------------------------------------------------------
// -- arrayTransformations.js
// -- initial author: Renick Bell (renick@gmail.com)
// -- initial creation date: Wed Jun 28 10:08:48 AM CST 2023
// -- contributors: Yiler Huang (yiler7777@gmail.com); Steve Wang (stevesg168@gmail.com)
// -- license: GPL 3.0
// --------------------------------------------------------------------------

//Takes the length the array should be changed into as argument. If array longer, will shorten array. If array shorter will loop the array until desiredLength:
//Generated with Chatgpt:
function adjustArrayLength(number, array) {
  const arrayLength = array.length;
  if (arrayLength === number) {
    return array;
  } else if (arrayLength < number) {
    const numCopies = Math.ceil(number / arrayLength);
    return array.concat(...Array(numCopies).fill(array)).slice(0, number);
  } else {
    return array.slice(0, number);
  }
}

//Set a size of the array and the array will be expanded or shrunk to fix that size. To expand it will just loop the array:
function resizeArray(number, array) {
  var arrayLength = array.length;
  if (arrayLength >= number) {
    return array.slice(0, number);
  }
  var repetitions = Math.ceil(number / arrayLength);
  var expandedArrayLength = repetitions * arrayLength;
  var expandedArray = new Array(expandedArrayLength);
  for (var i = 0; i < expandedArrayLength; i++) {
    expandedArray[i] = array[i % arrayLength];
  }
  return expandedArray.slice(0, number);
}

//Similar to the built-in slice function but with additional arguments that decide how many items to remove in a array and what they will be replaced wtih.
function safeSplice(inputArray, amountToRemove,indexToRemove,replaceWith) {
  let array1 = inputArray.slice(0, indexToRemove )
if (replaceWith!=undefined){
array1.push(replaceWith)}
  let array2 = inputArray.slice(indexToRemove + amountToRemove, inputArray.length)
  return array1.concat(array2)
}

//Removes all the instances of a specific item in an array.
function removeItem(arr, item){
     return arr.filter(f => f !== item)
}


function removeMultipleItems (arr, itemsToRemove){
    let sortedArray = arr
    itemsToRemove.forEach(x => {
        sortedArray = removeItem(sortedArray, x)
    })
    return sortedArray
}

//Takes an input array and scales its values from a given input range to a specified output range.
function scaleToRange (inputArray, inputMin, inputMax, outputMin, outputMax) {
    // add a check to make sure that inputMin and inputMax are not exceeded by values in inputArray?
    let scale = (outputMax - outputMin)/(inputMax - inputMin)
    return inputArray.map(x => ((x - inputMin) * scale) + outputMin)
}

//scales the elements in the "vals" array proportionally based on the desired "span". 
function scaleToSum (span,vals) {
    return vals.map(x => x * span/sum(vals))
}

//Picks an item randomly in an array.
function pick (inputArray) {
    return inputArray[Math.round((inputArray.length - 1) * Math.random())];
}

///Picks multiple items randomly in an array.
function pickN (n,inputArray) {
        let a = new Array(n);
        a.fill(0,0,n);
        let out = [];
        a.forEach(i => out.push(pick(inputArray)));
        return out 
}

//Sort the numbers in an array from small to big.
function low2HighSort (inputArray) { return inputArray.sort((a, b) => a - b)}

//Sort the numbers in an array from big to small.
function high2LowSort (inputArray) { return inputArray.sort((a, b) => b - a)}

//Takes a specific amount of items in an array. If the desired amount of items is longer than the length of the array, repeats it.
function takeN (inputArray, n) {
    let outputArray = [];
    for (let i = 0; i < n; i++)
    { outputArray.push(inputArray[i%(inputArray.length)])};
    return outputArray
}

//Constructs an output array by repeatedly taking elements from the inputArray until the length of the output reaches the targetLength.
function takeTo (targetLength, inputArray) {
    let output = [];
    let counter = 0;
    while (sum(output) < targetLength){
        let nextVal = inputArray[counter%(inputArray.length)];
        output.push(nextVal);
        counter++
    }
    if (sum(output) > targetLength) {
        outputSum = sum(output);
        let difference = outputSum - targetLength;
        output[output.length - 1] = output[output.length - 1] - difference;
    }
    return output
}

//Loops an array until its length meets the target length.
function loopTo (targetLength, inputArray) {
    let inputSum = sum(inputArray);
    let loopN = Math.ceil(targetLength/inputSum);
    let pre = R.flatten(buildArray(loopN, x => inputArray))
    return takeTo(targetLength,pre)
}

//Non ramda version:
// function zip (a,b) {return a.map((x, i) => { return [x, b[i]]; })}

//randa version:
//generated by chatgpt:
function zip (a,b) {return R.zip(a,b)}

// a is an array of arrays; this function concats b onto each of the arrays in a. b could be either an item or an array.
// arr1 = [[1,1,1],[2,2,2],[3,3,3]] 
// arr2 = [[4,4,4],[5,5,5],[6,6,6]] 
// buildZip(arr1,arr2)
// non ramda version:
// function buildZip (a,b) {return a.map((x,i) => x.concat(b[i]))}
//ramda version:
//generated by chatgpt:
function buildZip(a, b) {
  return R.zipWith(R.concat, a, b);
}

//Shuffle the order of items in an array.
function shuffle(array) {
  var currentIndex = array.length,  randomIndex;
  // While there remain elements to shuffle...
  while (currentIndex != 0) {
    // Pick a remaining element...
    randomIndex = Math.floor(Math.random() * currentIndex);
    currentIndex--;
    // And swap it with the current element.
    [array[currentIndex], array[randomIndex]] = [
      array[randomIndex], array[currentIndex]];
  }
  return array;
}

//Filters the inputArray based on whether any of the substrings in substringArray are found in each element.
function gatherBySubstring (inputArray, substringArray) {
    return inputArray.filter(x => substringArray.some(y => x.includes(y)))
}

//Flips a bolean. If input is true, returns false. If inputs is false, return true.
function flipBooleans (arr) {
    return arr.map (a => !a)
}
